The picture timer_div.png is a diagram of the hardware used for timing. The timer is a bit simplified, it doesn't explain a few behaviours that happen when the registers are writen at the same time as TIMA is incremented.

DIV register
------------

It works by using an internal 16 bit counter. The counter increases each clock (4 clocks per nop) and
the value of DIV is the 8 MSB of the counter: Increases every 256 oscilator clocks.

The value of DIV is the actual bits of the internal counter, not a mirror, not a register that increases with the internal counter: The actual bits of the counter mapped to memory.

DIV overflows at 64 Hz in normal speed mode, 128 Hz in double speed mode.

If written, its value is reseted to 0, as well as the internal counter.

- Interaction with timer and APU explained below.

- Serial clock is not derived from this internal counter, it is not affected by DIV register.

TIMER
-----

Shares the internal counter with DIV register. If DIV register is written, DIV internal counter is reseted, so TIMER is affected. For example, if a program configures the timer to increase every 64 clocks but it keeps writing to DIV register each 20 clocks, the timer will never increase its value.

That doesn't happen the other way. When writing to TAC to enable the timer the only thing that happens is that the register TIMA is allowed to increase, but it doesn't change the internal counter that increases TIMA.

- There's a glitch with DIV register. For example, if timer is configured to overflow every 256 clocks. If DIV is written when ( ( system_clocks & (256>>1) ) != 0 ) then the TIMA counter will increase once.

- Timer/DIV counter keeps increasing even if the timer is disabled. TIMA can increase just when the timer is enabled or it can need all the specified clocks by TAC, there is no way to know it without reseting DIV a few instructions before.

- Timer IRQ is delayed 1 nop (4 clocks) from the TIMA overflow. The TMA reload to TIMA is also delayed. For example (SYS is divided by 4 for easier understanding, each increment of the graph is 1 nop, not 1 clock):

  Timer overflows:
                  [A] [B]
    SYS  FD FE FF |00| 01 02
    TIMA FF FF FF |00| 23 23
    TMA  23 23 23 |23| 23 23
    IF   E0 E0 E0 |E0| E4 E4

  Timer doesn't overflow:

    SYS  FD FE FF 00 01 02
    TIMA 45 45 45 46 46 46
    TMA  23 23 23 23 23 23
    IF   E0 E0 E0 E0 E0 E0

During that strange cycle [A] you can prevent the IF flag from being set and prevent the TIMA from being reloaded from TMA by writing a value to TIMA. That new value will be the one that stays in the TIMA register after the instruction. Writing to DIV, TAC or other registers won't prevent the IF flag from being set or TIMA from being reloaded.

- If you write to TIMA during the cycle that TMA is being loaded to it [B], the write will be ignored and TMA value will be written to TIMA instead.

- If TMA is written the same cycle it is loaded to TIMA [B], TIMA is also loaded with that value.

- Writing to TAC doesn't reset the system counter.

- TAC glitches: Changing TAC value may produce an increment in TIMA. TIMA and IF don't have any strange behavior when incrementing, it's just a normal increment. The glitch depends on the hardware. GB/GBP work the same way, GBC, GBA and GBA SP are all different. I don't have SGB/SGB2 to test them. I suppose that they work the same way as the GB.

DIV interaction with APU
------------------------

- The APU uses the same internal counter as DIV to update sweep (channel 1), fade in/out and time out.

- In normal speed mode the APU updates when bit 5 of DIV overflows, in double speed when bit 6 overflows (256 Hz).

- Writing to DIV every instruction, for example, will make the APU produce the same frequency with the same volume even if sweep and fade out are enabled.

- Writing to DIV doesn't affect the frequency itself. The waveform generation is driven by another timer.